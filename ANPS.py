#---------------------------------------------------------------------
# Grant De La Campa
# @2019
# ANPS.py
# Functions:
#---------------------------------------------------------------------------------

import os
import os.path
import time
import datetime
import webbrowser
import win32print
import win32api
import dayCalculator
from datetime import date

#---------------------------------------------------------------------------------
#           BOOT
#---------------------------------------------------------------------------------
from ANPSboot import *
#---------------------------------------------------------------------------------
#           FORMATING
#---------------------------------------------------------------------------------
from ANPSFormat import *
#---------------------------------------------------------------------------------
#           Cleaner
#---------------------------------------------------------------------------------
from ANPScleaner import *
#---------------------------------------------------------------------------------
#           GLOBALS 
#---------------------------------------------------------------------------------

# Print log, stores what was printed after printer() runs
pLog = []
# Error log, stores jobs that failed to print after printer() runs
eLog = []

#---------------------------------------------------------------------------------
#           SETUP 
#---------------------------------------------------------------------------------

# Only called from priter when the errorstream !=0, builds missing directories referenced in DNM.anp
def ErrorRecovery(errorStream):
    breakpoint("PATH ERROR RECOVERY TOOL")
    valid = False
    query = ''
    count = 0
    while(valid != True):
        print("Paths that do not exist have been detected.")
        print("Would you like to repair the issue?")
        query = input("Y/N: ")
        if(query == 'Y') | (query == 'y'):
            for item in errorStream:
                responded = False
                while(responded != True):
                    print(item)
                    print("Would you like to create this directory? ")
                    response = input("Y/N: ")
                    if(response == 'Y') | (response == 'y'):
                        count= count +1
                        print("creating Dir: ", item)
                        responded = True
                        os.makedirs(item)
                        notePath = item + ("/Notes")
                        os.makedirs(notePath)
                        assignmentPath = item + ("/Assignments")
                        os.makedirs(assignmentPath)
                        homeworkPath = item + ("/HomeWork")
                        os.makedirs(homeworkPath)
                        readMe = item + "/README"
                        with open(readMe, "w") as file:
                            file.write("Grant De La Campa \n")
                            file.write("@2019 \n")
                            file.write("This directory: \n")
                            file.write(item + "\n")
                            file.write("Was autogenerated by ANPS.py script \n")
                            file.write("Includes: /Notes /Assignments /Homework /README.txt")
                    elif(response == 'N') | (response == 'n'):
                        print("Dir creation canceled")
                        responded = True
                    else:
                        eHandler(response)
            valid = True
        elif(query == 'N') | (query == 'n'):
            print("EXITING Subroutine ErrorRecovery()")
            valid = True
        else:
            eHandler(query)
    return count                                            # notify user how many directories were built

#---------------------------------------------------------------------------------
#           MENU KEYS
#---------------------------------------------------------------------------------

menuList = ['Menu','menu', 'M', 'm', 'options', 'o', 'O']
runList = ['1','Run','run','Run Script', 'R', 'r']
DNMList = ['2','DNM','DNM override', 'D', 'd', 'dnm']
scrubList = ['3','scub','Scrub','Scrub DL', 'S', 's']
logList = ['4','log','Log','l','L']
queueList =['5', 'print queue', 'queue', 'Q', 'q', 'Print queue', 'Print Queue']
infoList = ['6', 'I', 'i', 'Info', 'info', 'information']
helpList = ['7','help','Help', 'H', 'h']
exitList = ['8','Exit','Quit','quit','exit', 'E', 'e']
easterList = ['diablo']

#----------------------------------------------------------------------------------
#           PRINT SUBROUTINES
#----------------------------------------------------------------------------------

# This handles sending the document to the printer via win32api
def printSubRoutine(docPath):
    print("        -Printing: ", docPath)
    try:
        win32api.ShellExecute(0,"print",docPath, '/d:"%s"' % win32print.GetDefaultPrinter(),".",0)
        time.sleep(5)
    except win32api.error:
        eLog.append(docPath)

# prints default printer... some bug caused info option to not display the printer name without this method  
def getDefault():
    print("Default Printer: ", win32print.GetDefaultPrinter())

# prints the error log report for the printer
def pErrors():
    if not eLog:
        print("    -PrintSubRoutine() completed normally")
    else:
        print("    -The Following documents encountered errors:  ")
        for item in eLog:
            print("        -",item)
    
#----------------------------------------------------------------------------------
#           DATE SUBROUTINES
#----------------------------------------------------------------------------------

# Generic method to handler date/time input with lower and upper bounds.
def dateHandler(name, lower, upper):
    query = ''
    while(True):
        query = input(name)
        if(query.isdigit()):
            entry = int(query)
            if entry in range(lower, upper):
                return entry
            else:
                print("ERROR: Valid range is ", lower, "-", upper-1)
        else:
            eHandler(query)
            
#----------------------------------------------------------------------------------
#           TIME SUBROUTINES
#----------------------------------------------------------------------------------

# Printer calls this to update DNM.anp timestamp after each run
def setModTime():
    breakpoint("SETTING MOD TIME")
    now = datetime.datetime.now()
    then = datetime.datetime.fromtimestamp(os.path.getmtime("DNM.anp"))
    print("writing: ", datetime.datetime(now.year,now.month,now.day,now.hour,now.minute,now.second))
    print("overiding: ", datetime.datetime(then.year,then.month,then.day,then.hour,then.minute,then.second))
    modtime = time.mktime(now.timetuple())
    try:                                                                            # Success return 
        os.utime("DNM.anp",(modtime,modtime))
        return 2                                                    # Continue flag
    except: 
        return 1                                                    # restart flag
#get the desired date-time values from the user (Within constraints)
#upper bound is set to +1 since its an exclusive bound
def overideModTime():
    breakpoint("OVERIDE MOD TIME")
    print("WARNING: overiding DMN.anp mod time may result in reprinting")
    print("Please verify you would like to continue..")
    modQ  = ''
    while (True):        
        modQ = input("Y/N: ")
        if(modQ == 'Y') | (modQ == 'y'):
            print("Please enter overide values for the following: ")
            year = dateHandler("Year:   ", 1970, datetime.datetime.now().year+1)            # restricted from UNIX start to the current year
            month = dateHandler("Month:  ", 1, 13)
            day = dateHandler("Day:    ",1, dayCalculator.dayConstraint(year,month)+1)      # Upper bound calulated based on month & year
            hour = dateHandler("Hour:   ", 0, 24)
            minute = dateHandler("Minute: ", 0, 60)
            second = dateHandler("Second: ", 0, 60)
            modDate = datetime.datetime(year,month,day,hour,minute,second)                  # build the Mod date from the user input
            modTuple = time.mktime(modDate.timetuple())                                     # create the proper tiemstamp object to set modtime
            os.utime("DNM.anp", (modTuple, modTuple))                                       # set the mod time of DNM.anp
            print("Modification complete DNM.anp set to: ", modDate)
            print("NOTICE: ANPS must restart to take effect")
            time.sleep(2)
            ret = 1                                                                         #RESET flag sent to ANPSlauncher to restart the ANPS script
            break;
        elif(modQ == 'N') | (modQ == 'n'):
            print("Exiting subrouting overideModTime()")
            ret = 2                                                                         #CONTINUE flag sent to ANPSlauncher to continue running ANPS
            break;
        elif(modQ == 'C'):                                                                  #hidden feature gets the DNM timestamp
            print("Current DNM: ", datetime.datetime.fromtimestamp(os.path.getmtime("DNM.anp")))
        else:
            eHandler(modQ)
    return ret
            
    
#---------------------------------------------------------------------------------
#           DIRECTORY SUBROUTINES
#---------------------------------------------------------------------------------

# iterates through given user directories and prints documents of the targeted type
def printer(mainDir, sublist):
    breakpoint("PRINTING FROM DIRECTORIES")
    errorStream = []
    repaired = 0
    if(os.path.exists("DNM.anp") == False):
        os.system('cls')
        breakpoint("FATAL ERROR ENCOUNTERED");
        print("     - Call Stack: ANPS.Main.printer")
        print("     - Missing DNM.anp")
        print("     - System exit code 1")
        time.sleep(3)                                                               # Give user time to read error message
        return 1                                                                    # Send exit code 1 to main to pass to ANPSlauncher.py
    print("Begining directory search @" + mainDir) 
    for extention in sublist:
        tempPath = mainDir + extention
        if(os.path.exists(tempPath) != False):
            print("    In Directory: ", tempPath)
            for sub in os.listdir(tempPath):
                filePath = tempPath + "/" + sub
                # removed sub.endswith('.pdf') 
                if ( sub.endswith('.docx') | sub.endswith('.txt') | sub.endswith('.pdf') ) :
                    # check if the file found was created/modified after the DNM timestamp
                    if os.path.getmtime(filePath) >= os.path.getmtime("DNM.anp"):
                        printSubRoutine(filePath)
                        pLog.append(sub)
        else:
            eHandler("===========>" + tempPath)         #custom format through eHandler
            errorStream.append(tempPath)    #Build the errorStream to send to the ErrorRecovery tool
    print("RUN REPORT:")
    print("    -" + str(len(errorStream)) + " directory Errors Occured")
    if (errorStream):                                   #returns only if errorStream is not empty 
        print("    -" + str(ErrorRecovery(errorStream)) + " directory Errors Repaired")
    pErrors()
    return setModTime()                                        #update dnm.anp timestamp to current time

# Deletes duplicate files from the downloads of the user.
def scrub(mainDir, dlDir, subDir):
    breakpoint("SCRUB DOWNLOADS")
    print("WARNING: This will delete files from:", dlDir)
    print("Please verify you would like to continue..")
    scrubQ = ''
    while(True):
        scrubQ = input("Y/N: ")
        if(scrubQ == 'Y') | (scrubQ == 'y'):
            cleaner_start(mainDir, dlDir, subDir)
            break
        elif(scrubQ == 'Y*'):               #hidden option to remove all files from the download directory
            print("Nuclear Option Selected...")
            for item in os.listdir(dlDir):
                print("     -Removing: ", item)
                try:
                    os.remove(dlDir + "/" + item)
                except os.error:
                    eLog.append(os.error)
                    eHandler(os.error)
            break;
        elif(scrubQ == 'N') | (scrubQ == 'n'):
            print("Exiting subrouting scrub()")
            break;
        else:
            eHandler(scrubQ)
            
#I was listening to this song when I wrote this script, RIP.
def eggs():
    print("Who told you about this!?")
    webbrowser.open('https://www.youtube.com/watch?v=KlQESTshOPw')
    time.sleep(10)
    sys.exit()
    
#---------------------------------------------------------------------------------
#           MENU CONTROLLERS
#---------------------------------------------------------------------------------

def info(mainDir, dlDir, subDir):
    breakpoint("INFO")
    print("A.N.P.S: Automated Network Printer Script")
    print("@Grant De La Campa")
    print("2019")
    print("Version: V4")
    print("Main Directory: ", mainDir)
    print("Download Directory: ", dlDir)
    print("Subject Directory: ")
    for item in subDir:
        print("     -", item)
    try:
        print("Last Run: ", datetime.datetime.fromtimestamp(os.path.getmtime("DNM.anp")))
    except:
        print("Last Run: Error reading datetime.datetime.fromtimestamp(os.path.getmtime(\"DNM.anp\")")
    getDefault()                #gets default printer
    
def helpM():
    breakpoint("HELP")
    print("#: Menu: ")
    print("     -Description: Launches the user menu to display options")
    listCalls(menuList)         #List printer used for keys to activate menu option
    print("1: Run Script: ")
    print("     -Description: Fires off the print script to iterate on interal directories.")
    listCalls(runList)
    print("2: DNM override: ")
    print("     -Description: Allows the user to roll back the target date for printing.")
    print("                   Restricted to any year between 1/1/1970 and the current year.")
    listCalls(DNMList)
    print("3: Scrub DL: ")
    print("     -Description: If the log contains any files this will remove duplicates from ")
    print("                   the downloads folder.")
    listCalls(scrubList)
    print("4: Print Log: ")
    print("     -Description: Prints a log of the printed files after running the script")
    listCalls(logList)
    print("5: Queue")
    print("     -Description: Launches native browser to check queued files on printsmart")
    listCalls(queueList)
    print("6: Info: ")
    print("     -Description: Gives info about the program.")
    listCalls(infoList)
    print("7: Help: ")
    print("     -Description: The current menu being displayed, gives a list of commands.")
    listCalls(helpList)
    print("8: Quit: ")
    print("     -Description: Exit the ANPS shell")
    listCalls(exitList)

def menu():
    breakpoint("MENU")
    print("1: Print new files")
    print("2: DNM date override")
    print("3: clean downloads")
    print("4: Printed Log")
    print("5: Print queue")
    print("6: System Info")
    print("7: Help")
    print("8: Quit")


def log():
    breakpoint("LOG")
    if(pLog == []):
        print("Log is empty please run script to populate")
    else:
        for item in pLog:
            print("     -", item)

def queue():
    breakpoint("QUEUE")
    print("WARINING: This will launch your default Web Browser...")
    print("NOTE: Login information is required")
    print("Please verify you would like to continue..")
    webQ = ''
    while(True):
        webQ = input("Y/N: ")
        if(webQ == 'Y') | (webQ == 'y'):
            webbrowser.open("https://printsmart.csus.edu/app?service=page/UserReleaseJobs")
            break;
        elif(webQ == 'N')| (webQ == 'n'):
            print("Exiting Subroutine Queue()")
            break;
        else:
            eHandler(webQ)
    
#---------------------------------------------------------------------------------
#           MAIN 
#---------------------------------------------------------------------------------
# Intended to be the only External Interface
# To run ANPS call main()
# If this interface is run directly and not via ANPSLauncher.py it will not properly handle returns. 
def main():
    try:                                                #files loaded/created normally
        boot = IO_BOOT()
        boot.boot()
    except BufferError as b:                            # error somewhere in the file read/write
        breakpoint("FATAL BOOT ERROR ENCOUNTERED")
        print("ERROR: ", b)
        print("Removing DNM.anp")
        os.remove("DNM.anp")                            #Assume DNM.anp has been corrupted, delete corupted file
        time.sleep(5)
        return 1                                        #send RESET flag to ANPSLauncher
    mainDir = boot.getMain()                            #get the main directory from the boot routine 
    dlDir = boot.getDownloads()                         #get the downloads directory from the boot routine
    subDir = boot.getSub()                              #get the list of subject directories from the boot routine
    query = ''
    print("A.N.P.S Shell V2 @2019")
    menu()
    while(query != 'Exit'):
        query = input("ANPS>> ")
        if(query in runList):                           #Option 1 selected: Runs printer script
            os.system('cls')
            ret = printer(mainDir, subDir)
            if(ret == 1):
                return 1                                #return restart code 
        elif(query in DNMList):                         #option 2 selected: Runs time-stamp rollback/foreward feature 
            os.system('cls')
            return overideModTime()
        elif(query in infoList):                        #option 3 selected: returns the program status and information
            os.system('cls')
            info(mainDir, dlDir, subDir)
        elif(query in helpList):                        #option 4: returns the help list 
            os.system('cls')
            helpM()
        elif(query in scrubList):                       #option 5: uses the print log from option 1 to remove duplicate files in the downloads folder.
            os.system('cls')
            scrub(mainDir, dlDir, subDir)
        elif(query in logList):                         #option 6: returns the pLog
            os.system('cls')
            log()
        elif(query in easterList):                      #option -: easter egg 
            os.system('cls')    
            eggs()
        elif(query in queueList):                       #option 7: points to the printsmart api 
            os.system('cls')
            queue()
        elif(query in menuList):                        #option -: returns the menu 
            os.system('cls')    
            menu()
        elif(query in exitList):                        #option 8: exist the program 
            return 0;                                   #return exit code
        else:
            eHandler(query)
